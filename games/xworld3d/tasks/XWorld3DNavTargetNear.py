import random
from xworld3d_task import XWorld3DTask
from maze2d import print_env

"""
This file implements an xworld teaching task.
The task class contains several stage functions.

Each stage function must return three outputs:

next_stage  - the name of the next stage function
reward      - the reward of the current stage
sentence    - the sentence generated by the current stage

Finally, the function get_stage_names() return all the stage functions the
user wants to register.

This task askes the agent to go to an object that is referred to by another nearby object.

Example:
Please go to the object that is near the apple.
"""

class XWorld3DNavTargetNear(XWorld3DTask):
    def __init__(self, env):
        super(XWorld3DNavTargetNear, self).__init__(env)

    def idle(self):
        dt = 1.5 # eight connected neighborhood
        goals = self._get_goals()
        ## because agent loc is continuous, we have to rely on its init position for path search
        init_agent_loc = self.env.init_agent_loc

        pairs = []
        for g in goals:
            around_goals = self._get_surrounding_goals(distance_threshold=dt, refer=g)
            if len(around_goals) == 1 and self._reachable(init_agent_loc, around_goals[0].loc):
                ## (target, reference)
                pairs.append((around_goals[0], g))

        if pairs:
            pair = random.choice(pairs)
            self._record_target(pair[0]);
            self._bind("S -> start")
            self._bind("G -> '" + pair[1].name + "'")
            self.sentence = self._generate()
            return ["simple_navigation_reward", 0.0, self.sentence]
        elif len(goals) >= 2: ## multiple goals
            ## else the teacher then has the chance to change the map
            random.shuffle(goals)
            for g in goals:
                empty_grids = [e for e in self._get_surrounding_empty_grids(distance_threshold=dt, refer=g) if \
                               init_agent_loc != e and self._reachable(init_agent_loc, e)]
                if empty_grids:
                    break
            # There is a small chance that no such reachable empty grid is found,
            # when the map is really crowded; this map is "useless" for this task
            if empty_grids:
                goals.remove(g)
                self._move_entity(goals[0], empty_grids[0])

        return ["idle", 0.0, ""]

    def get_stage_names(self):
        """
        return all the stage names; does not have to be in order
        """
        return ["idle", "simple_navigation_reward"]

    def _define_grammar(self):
        all_goal_names = self._get_all_goal_names_as_rhs()
        grammar_str = """
        S --> start | timeup | correct | wrong
        start -> I0 | I1 | I2 | I3 | I4
        correct -> 'Well' 'done' '!'
        wrong -> 'Wrong' '!'
        timeup -> 'Time' 'up' '.'
        I0 -> A NP G
        I1 -> A NP G 'please' '.'
        I2 -> 'Please' A NP G '.'
        I3 -> NP G 'is' 'your' D '.'
        I4 -> Y A NP G '?'
        A -> 'go' 'to' | 'navigate' 'to' | 'reach' | 'move' 'to' | 'collect'
        NP -> 'the' 'object' N
        N -> 'near' | 'by' | 'besides'
        Y -> 'Could' 'you' 'please' | 'Can' 'you' | 'Will' 'you'
        D -> 'destination' | 'target' | 'goal' | 'end'
        G --> %s
        """ % all_goal_names
        return grammar_str, "S"
