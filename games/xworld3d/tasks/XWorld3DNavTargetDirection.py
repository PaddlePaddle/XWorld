import random
import math
from xworld3d_task import XWorld3DTask
from maze2d import print_env

"""This file implements an xworld teaching task.
The task class contains several stage functions.

Each stage function must return three outputs:

next_stage  - the name of the next stage function
reward      - the reward of the current stage
sentence    - the sentence generated by the current stage

Finally, the function get_stage_names() return all the stage functions the
user wants to register.

This task asks the agent to navigate to an object whose direciton is
described wrt to another nearby object (from the agent' perspective).

Example:
Please go the object that is left of the apple.
"""

class XWorld3DNavTargetDirection(XWorld3DTask):
    def __init__(self, env):
        super(XWorld3DNavTargetDirection, self).__init__(env)

    def idle(self):
        goals = self._get_goals()
        agent, _, _ = self._get_agent()

        assert len(goals) >= 2, "This task must have at least two goals"

        self._delete_entity(agent)
        random.shuffle(goals)
        g1, g2 = goals[:2]
        # delete goals to make space
        self._delete_entity(g1)
        self._delete_entity(g2)

        tiles = self._get_l_tiles()
        assert tiles, "map too crowded?"

        random.shuffle(tiles)
        g1.loc, g2.loc = tiles[0]
        self._set_entity_inst(g1)
        self._set_entity_inst(g2)

        empty_grids = self._get_surrounding_empty_grids(
            refer=g1.loc, distance_threshold=1.0)
        if empty_grids:
            target, referent = g1, g2
        else:
            empty_grids = self._get_surrounding_empty_grids(
                refer=g2.loc, distance_threshold=1.0)
            assert empty_grids, "get_l_tiles() is buggy"
            target, referent = g2, g1

        e = random.choice(empty_grids)
        direction = self.__compute_triple_direction(target, referent, e)

        assert direction != "behind", "Impossible!"

        ## move agent to the new position
        new_a = self._propagate_agent([e], inclusive=True)
        assert new_a, "This shouldn't happen because empty_grid is already empty!"
        agent.loc, _ = random.choice(new_a)
        self._set_entity_inst(agent)

        self._record_target((referent, direction));
        self._bind("S -> start")
        self._bind("G -> '" + referent.name + "'")
        self._bind("P -> " + direction.upper())
        self.sentence = self._generate()
        return ["navigation_reward", 0.0, self.sentence]

    def navigation_reward(self):
        reward, time_out = self._time_reward()
        if not time_out:
            agent, _, _ = self._get_agent()
            referent, direction = self.target
            objects_reach_test = [(self.__compute_triple_direction(g, referent, agent.loc, agent.yaw),
                                   self._get_distance(g.loc, referent.loc) < 1.0 + 1e-3)\
                                  for g in self._get_goals() \
                                  if self._reach_object(agent.loc, agent.yaw, g)]
            if (direction, True) in objects_reach_test:
                reward = self._successful_goal(reward)
            elif objects_reach_test:
                reward = self._failed_goal(reward)
        return ["navigation_reward", reward, self.sentence]

    def __compute_triple_direction(self, target, referent, a, view_yaw=None):
        """
        Compute the direction of target to referent in the agent's view
        """
        if view_yaw is None:
            view_yaw = math.atan2(target.loc[1] - a[1], target.loc[0] - a[0])

        theta, dist, _ = self._get_direction_and_distance(target.loc, referent.loc, view_yaw)
        if dist == 0:
            return False

        sign = True if theta > 0 else False
        flag = False # referent is far
        theta = abs(theta)
        if theta > XWorld3DTask.PI_2:
            flag = True # target is far
            theta = XWorld3DTask.PI - theta

        if theta < XWorld3DTask.PI_4 + 1e-3: # front or behind
            if flag:
                return "behind"
            else:
                return "front"
        elif XWorld3DTask.PI_2 - theta < XWorld3DTask.PI_4 + 1e-3: # left or right
            if sign:
                ## xworld2d has opposite "left" and "right"
                return ("left" if "3D" in self.env.__class__.__name__ else "right")
            else:
                return ("right" if "3D" in self.env.__class__.__name__ else "left")
        return False

    def get_stage_names(self):
        """
        return all the stage names; does not have to be in order
        """
        return ["idle", "navigation_reward"]

    def _define_grammar(self):
        all_goal_names = self._get_all_goal_names_as_rhs()
        grammar_str = """
        S --> start | timeup | correct | wrong
        start -> I0 | I1 | I2 | I3 | I4
        correct -> 'Well' 'done' '!'
        wrong -> 'Wrong' '!'
        timeup -> 'Time' 'up' '.'
        I0 -> A NP G '.'
        I1 -> A NP G 'please' '.'
        I2 -> 'Please' A NP G '.'
        I3 -> NP G 'is' 'your' D '.'
        I4 -> Y A NP G '?'
        A -> 'go' 'to' | 'navigate' 'to' | 'reach' | 'move' 'to' | 'collect'
        NP -> 'the' 'object' P | 'the' 'object' 'that' 'is' P
        P --> LEFT | RIGHT | BEHIND | FRONT
        LEFT -> 'left' 'of' | 'to' 'the' 'left' 'of'
        RIGHT -> 'right' 'of' | 'to' 'the' 'right' 'of'
        BEHIND -> 'behind'
        FRONT -> 'in' 'the' 'front' 'of' | 'front' 'of'
        Y -> 'Could' 'you' 'please' | 'Can' 'you' | 'Will' 'you'
        D -> 'destination' | 'target' | 'goal' | 'end'
        G --> %s
        """ % all_goal_names
        return grammar_str, "S"
