import random
import math
from xworld3d_task import XWorld3DTask
from maze2d import print_env

"""
This file implements an xworld teaching task.
The task class contains several stage functions.

Each stage function must return three outputs:

next_stage  - the name of the next stage function
reward      - the reward of the current stage
sentence    - the sentence generated by the current stage

Finally, the function get_stage_names() return all the stage functions the
user wants to register.

This task asks the agent to go to a place between two objects.

Example:
Please go between the table and the chair.
"""

class XWorld3DNavTargetBetween(XWorld3DTask):
    def __init__(self, env):
        super(XWorld3DNavTargetBetween, self).__init__(env)

    def idle(self):
        goals = self._get_goals()
        agent, _, _ = self._get_agent()

        assert len(goals) >= 2, "This task must have at least two goals"

        self._delete_entity(agent)

        random.shuffle(goals)
        g1, g2 = goals[:2]
        ## first delete goals to make space
        self._delete_entity(g1)
        self._delete_entity(g2)

        ## else the teacher then has the chance to change the map
        t_tiles = self._get_t_tiles()
        assert t_tiles, "map too crowded?"

        random.shuffle(t_tiles)
        g1.loc, g2.loc = t_tiles[0]
        self._set_entity_inst(g1)
        self._set_entity_inst(g2)

        new_a = self._propagate_agent([self._middle_loc(g1.loc, g2.loc)])
        assert new_a, "get_t_tiles() is buggy"
        new_a = random.choice(new_a)

        agent.loc = new_a
        self._set_entity_inst(agent)

        self._record_target((g1.loc, g2.loc));
        self._bind("S -> start")
        self._bind("G1 -> '" + g1.name + "'")
        self._bind("G2 -> '" + g2.name + "'")
        self.sentence = self._generate()
        return ["navigation_reward", 0.0, self.sentence]

    def navigation_reward(self):
        reward, time_out = self._time_reward()
        if not time_out:
            agent, _, _ = self._get_agent()
            objects_reach_test = [g.id for g in self._get_goals() \
                                  if self._reach_object(agent.loc, agent.yaw, g)]
            if objects_reach_test:
                reward = self._failed_goal(reward)
            else:
                o1, o2 = self.target
                threshold = 1.0
                theta, dist, _ = self._get_direction_and_distance(
                    agent.loc, self._middle_loc(o1, o2), agent.yaw)
                if abs(theta) < self.orientation_threshold \
                   and dist < threshold \
                   and dist > threshold / 2:
                    reward = self._successful_goal(reward)
        return ["navigation_reward", reward, self.sentence]

    def get_stage_names(self):
        """
        return all the stage names; does not have to be in order
        """
        return ["idle", "navigation_reward"]

    def _define_grammar(self):
        all_goal_names = self._get_all_goal_names_as_rhs()
        grammar_str = """
        S --> start | timeup | correct | wrong
        start -> I0 | I1 | I2 | I3 | I4
        correct -> 'Well' 'done' '!'
        wrong -> 'Wrong' '!'
        timeup -> 'Time' 'up' '.'
        I0 -> A L B '.'
        I1 -> A L B 'please' '.'
        I2 -> 'Please' A L B '.'
        I3 -> L B 'is' 'your' D '.'
        I4 -> Y A L B '?'
        A -> 'go' 'to' | 'navigate' 'to' | 'reach' | 'move' 'to'
        B -> 'between' G1 'and' G2
        L -> 'the' 'location' | 'the' 'grid' | 'the' 'place'
        Y -> 'Could' 'you' 'please' | 'Can' 'you' | 'Will' 'you'
        D -> 'destination' | 'target' | 'goal' | 'end'
        G1 --> %s
        G2 --> %s
        """ % (all_goal_names, all_goal_names)
        return grammar_str, "S"
