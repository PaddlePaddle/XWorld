import random
import math
from xworld3d_task import XWorld3DTask
from maze2d import print_env

"""This file implements an xworld teaching task.
The task class contains several stage functions.

Each stage function must return three outputs:

next_stage  - the name of the next stage function
reward      - the reward of the current stage
sentence    - the sentence generated by the current stage

Finally, the function get_stage_names() return all the stage functions the
user wants to register.

This task asks the agent to navigate to an object which is farthest
away from or closest to (in euclidean distance) the referent than another
object.

Example:
Please move to the object that is farthest away from the apple.
"""

class XWorld3DNavTargetDistance(XWorld3DTask):
    def __init__(self, env):
        super(XWorld3DNavTargetDistance, self).__init__(env)

    def idle(self):
        goals = self._get_goals()
        agent, _, _ = self._get_agent()

        assert len(goals) >= 3, "This task must have at least three goals"

        target = random.choice([g for g in goals if self._reachable(agent.loc, g.loc)])

        goals.remove(target)
        random.shuffle(goals)

        ## find a referent so that the target has either the maximal
        ## or the minimal distance to it
        distance_str = ""
        for r in goals:
            target_dist = self._get_distance(target.loc, r.loc)
            other_dists = [self._get_distance(g.loc, r.loc) for g in goals if g.id != r.id]
            if target_dist < min(other_dists):
                distance_str = "CLOSE"
                break
            if target_dist > max(other_dists):
                distance_str = "FAR"
                break

        assert distance_str != "", "Our maps are grid-like and thus valid targets must exist"

        self._record_target(target);
        self._bind("S -> start")
        self._bind("G -> '" + r.name + "'")
        self._bind("D -> " + distance_str)
        self.sentence = self._generate()
        return ["navigation_reward", 0.0, self.sentence]

    def navigation_reward(self):
        reward, time_out = self._time_reward()
        if not time_out:
            agent, _, _ = self._get_agent()
            objects_reach_test = [g.id for g in self._get_goals() \
                                  if self._reach_object(agent.loc, agent.yaw, g)]
            if self.target.id in objects_reach_test:
                reward = self._successful_goal(reward)
            elif objects_reach_test:
                reward = self._failed_goal(reward)
        return ["navigation_reward", reward, self.sentence]

    def get_stage_names(self):
        """
        return all the stage names; does not have to be in order
        """
        return ["idle", "navigation_reward"]

    def _define_grammar(self):
        all_goal_names = self._get_all_goal_names_as_rhs()
        grammar_str = """
        S --> start | timeup | correct | wrong
        start -> I0 | I1 | I2
        correct -> 'Well' 'done' '!'
        wrong -> 'Wrong' '!'
        timeup -> 'Time' 'up' '.'
        I0 -> A 'the' O D G '.'
        I1 -> Y A 'the' O D G '?'
        I2 -> O D G '.'
        A -> 'go' 'to' | 'navigate' 'to' | 'reach' | 'move' 'to' | 'collect'
        OO -> 'object' | 'target'
        O -> OO 'that' 'is' | OO
        D --> FAR | CLOSE
        FAR -> 'farthest' 'away' 'from' | 'most' 'distant' 'from'
        CLOSE -> 'closest' 'to' | 'least' 'distant' 'from' | 'nearest' 'to'
        Y -> 'Could' 'you' 'please' | 'Can' 'you' | 'Will' 'you'
        G --> %s
        """ % all_goal_names
        return grammar_str, "S"
