#version 430
#extension GL_ARB_shader_image_load_store : require
layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(binding = 0) uniform sampler3D voxelAlbedo;
layout(binding = 1, rgba8) uniform image3D voxelNormal;
layout(binding = 2, rgba8) uniform image3D writeonly voxelRadiance;
layout(binding = 3, rgba8) uniform image3D readonly voxelEmissive;

const float PI = 3.14159265f;
const float EPSILON = 1e-30;
const float SQRT_3 = 1.73205080f;
const uint MAX_DIRECTIONAL_LIGHTS = 1;

// struct Attenuation
// {
//     float constant;
//     float linear;
//     float quadratic;
// };

struct Light {
    vec3 diffuse;
    vec3 direction;
    //Attenuation attenuation;
};

uniform Light directionalLight[MAX_DIRECTIONAL_LIGHTS];

uniform vec2 exponents;
uniform float voxelSize;
uniform float voxelScale;
uniform vec3 worldMinPoint;
uniform int volumeDimension;
uniform uint normalWeightedLambert = 1;
uniform float traceShadowHit;
uniform int numDirectionalLight;

vec3 VoxelToWorld(ivec3 pos)
{
    vec3 result = vec3(pos);
    result *= voxelSize;

    return result + worldMinPoint;
}

vec3 WorldToVoxel(vec3 position)
{
    vec3 voxelPos = position - worldMinPoint;
    return voxelPos * voxelScale;
}

float TraceShadow(vec3 position, vec3 direction, float maxTracingDistance) 
{
    // scaling factor
    float k = traceShadowHit * traceShadowHit;
    // navigation
    float voxelTexSize = 1.0f / volumeDimension;
    // move one voxel further to avoid self collision
    float dst = voxelTexSize * 2.0f;
    vec3 samplePos = direction * dst + position;
    // control variables
    float visibility = 0.0f;
    // accumulated sample
    float traceSample = 0.0f;

    while (visibility <= 1.0f && dst <= maxTracingDistance) 
    {
        if (samplePos.x < 0.0f || samplePos.y < 0.0f || samplePos.z < 0.0f
            || samplePos.x > 1.0f || samplePos.y > 1.0f || samplePos.z > 1.0f) 
        { 
            break; 
        }
        
        traceSample = ceil(texture(voxelAlbedo, samplePos).a) * k;

        // hard shadows mode
        if(traceSample > 1.0f - EPSILON) { return 0.0f; }

        // accumulate
        visibility += (1.0f - visibility) * traceSample / (dst * dst);
        // move further into volume
        dst += voxelTexSize;
        samplePos = direction * dst + position;
    }

    return 1.0f - visibility;
}


vec3 BRDF(Light light, vec3 normal, vec3 albedo)
{
    float nDotL = 0.0f;

    if(normalWeightedLambert == 1)
    {
        vec3 weight = normal * normal;

        float rDotL = dot(vec3(1.0, 0.0, 0.0), light.direction);
        float uDotL = dot(vec3(0.0, 1.0, 0.0), light.direction);
        float fDotL = dot(vec3(0.0, 0.0, 1.0), light.direction);

        rDotL = normal.x > 0.0 ? max(rDotL, 0.0) : max(-rDotL, 0.0);
        uDotL = normal.y > 0.0 ? max(uDotL, 0.0) : max(-uDotL, 0.0);
        fDotL = normal.z > 0.0 ? max(fDotL, 0.0) : max(-fDotL, 0.0);

        nDotL = rDotL * weight.x + uDotL * weight.y + fDotL * weight.z;
    }
    else
    {
        nDotL = max(dot(normal, light.direction), 0.0f);
    }

    return light.diffuse * albedo * nDotL;
}


vec4 CalculateDirectional(Light light, vec3 normal, vec3 position, vec3 albedo)
{
    float visibility = 1.0f;

    vec3 voxelPos = WorldToVoxel(position);
    visibility = TraceShadow(voxelPos, light.direction, 1.0f);

    if(visibility == 0.0f) return vec4(0.0f); 

    return vec4(BRDF(light, normal, albedo) * visibility, visibility);
}

vec4 CalculateDirectLighting(vec3 position, vec3 normal, vec3 albedo)
{
    normal = normalize(normal);
    // world space grid voxel size
    float voxelWorldSize = 1.0 /  (voxelScale * volumeDimension);

    vec4 directLighting = vec4(0.0f, 0.0f, 0.0f, 0.0f);
    vec4 current =  vec4(0.0f); int count = 1;
    position = position + normal * voxelWorldSize * 0.5f;

    for (uint i = 0; i < numDirectionalLight; ++i)
    {
        current = CalculateDirectional(directionalLight[i], normal, position, albedo);
        directLighting.rgb += current.rgb;
        directLighting.a += current.a; 
    }

    return directLighting;
}

vec3 EncodeNormal(vec3 normal)
{
    return normal * 0.5f + vec3(0.5f);
}

vec3 DecodeNormal(vec3 normal)
{
    return normal * 2.0f - vec3(1.0f);
}

void main()
{
	if(gl_GlobalInvocationID.x >= volumeDimension ||
		gl_GlobalInvocationID.y >= volumeDimension ||
		gl_GlobalInvocationID.z >= volumeDimension) return;

	ivec3 writePos = ivec3(gl_GlobalInvocationID);

	vec4 albedo = texelFetch(voxelAlbedo, writePos, 0);

    if(albedo.a < EPSILON) { return; }

    albedo.a = 0.0f;

    vec3 baseNormal = imageLoad(voxelNormal, writePos).xyz;

    vec3 normal = DecodeNormal(baseNormal);

    vec3 emissive = imageLoad(voxelEmissive, writePos).rgb;

    memoryBarrierImage();

    if(any(greaterThan(albedo.rgb, vec3(0.0f))))
    {
        vec3 wsPosition = VoxelToWorld(writePos);
        albedo = CalculateDirectLighting(wsPosition, normal, albedo.rgb);
    }


    float alpha = albedo.a;

    albedo.rgb += emissive;
    albedo.a = 1.0f;

    imageStore(voxelRadiance, writePos, albedo);
    imageStore(voxelNormal, writePos, vec4(baseNormal, alpha));
}