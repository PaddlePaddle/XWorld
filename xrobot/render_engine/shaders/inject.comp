#version 430
#extension GL_ARB_shader_image_load_store : require
layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(binding = 0) uniform sampler3D voxelAlbedo;
layout(binding = 1, rgba8) uniform image3D voxelNormal;
layout(binding = 2, rgba8) uniform image3D writeonly voxelRadiance;
layout(binding = 3, rgba8) uniform image3D readonly voxelEmissive;
layout(binding = 4) uniform sampler2D s_ShadowMap[8];

const float PI = 3.14159265f;
const float EPSILON = 1e-30;
const float SQRT_3 = 1.73205080f;
const uint MAX_DIRECTIONAL_LIGHTS = 1;

// struct Attenuation
// {
//     float constant;
//     float linear;
//     float quadratic;
// };

struct Light {
    vec3 diffuse;
    vec3 direction;
    //Attenuation attenuation;
};

uniform Light directionalLight[MAX_DIRECTIONAL_LIGHTS];

uniform vec2 exponents;
uniform float voxelSize;
uniform float voxelScale;
uniform vec3 worldMinPoint;
uniform int volumeDimension;
uniform uint normalWeightedLambert = 1;
uniform float traceShadowHit;
uniform int numDirectionalLight;
uniform int shadowMode = 1; // 0 ShadowMap
uniform vec4 direction;
uniform vec4 options;
uniform int num_cascades;
uniform float far_bounds[8];
uniform mat4 texture_matrices[8];
uniform vec3 camera_position;

float depth_compare(float a, float b, float bias)
{
    return a - bias > b ? 1.0 : 0.0;
}

float shadow_occlussion(float frag_depth, vec3 n, vec3 l, vec3 x)
{
    int index = num_cascades - 2;
    
    // for (int i = 0; i < num_cascades - 1; i++)
    // {
    //     if (frag_depth > far_bounds[i])
    //         index = i + 1;
    // }

    // Transform frag position into Light-space.
    vec4 light_space_pos = texture_matrices[index] * vec4(x, 1.0f);
    float current_depth = light_space_pos.z;
    
    float bias = max(0.0005 * (1.0 - dot(n, l)), 0.0005);  
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(s_ShadowMap[index], 0).xy;
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(s_ShadowMap[index], vec2(light_space_pos.xy + vec2(x, y) * texelSize)).r; 
            shadow += current_depth - bias > pcfDepth ? 1.0 : 0.0;        
        }    
    }
    shadow /= 9.0;

    
    return shadow;
}

vec3 VoxelToWorld(ivec3 pos)
{
    vec3 result = vec3(pos);
    result *= voxelSize;

    return result + worldMinPoint;
}

vec3 WorldToVoxel(vec3 position)
{
    vec3 voxelPos = position - worldMinPoint;
    return voxelPos * voxelScale;
}

float TraceShadow(vec3 position, vec3 direction, float maxTracingDistance) 
{
    // scaling factor
    float k = traceShadowHit * traceShadowHit;
    // navigation
    float voxelTexSize = 1.0f / volumeDimension;
    // move one voxel further to avoid self collision
    float dst = voxelTexSize * 2.0f;
    vec3 samplePos = direction * dst + position;
    // control variables
    float visibility = 0.0f;
    // accumulated sample
    float traceSample = 0.0f;

    while (visibility <= 1.0f && dst <= maxTracingDistance) 
    {
        if (samplePos.x < 0.0f || samplePos.y < 0.0f || samplePos.z < 0.0f
            || samplePos.x > 1.0f || samplePos.y > 1.0f || samplePos.z > 1.0f) 
        { 
            break; 
        }
        
        traceSample = ceil(texture(voxelAlbedo, samplePos).a) * k;

        // hard shadows mode
        if(traceSample > 1.0f - EPSILON) { return 0.0f; }

        // accumulate
        visibility += (1.0f - visibility) * traceSample / (dst * 1);
        // move further into volume
        dst += voxelTexSize;
        samplePos = direction * dst + position;
    }

    return 1.0f - visibility;
}


vec3 BRDF(Light light, vec3 normal, vec3 albedo)
{
    float nDotL = 0.0f;

    if(normalWeightedLambert == 1)
    {
        vec3 weight = normal * normal;

        float rDotL = dot(vec3(1.0, 0.0, 0.0), light.direction);
        float uDotL = dot(vec3(0.0, 1.0, 0.0), light.direction);
        float fDotL = dot(vec3(0.0, 0.0, 1.0), light.direction);

        rDotL = normal.x > 0.0 ? max(rDotL, 0.0) : max(-rDotL, 0.0);
        uDotL = normal.y > 0.0 ? max(uDotL, 0.0) : max(-uDotL, 0.0);
        fDotL = normal.z > 0.0 ? max(fDotL, 0.0) : max(-fDotL, 0.0);

        nDotL = rDotL * weight.x + uDotL * weight.y + fDotL * weight.z;
    }
    else
    {
        nDotL = max(dot(normal, light.direction), 0.0f);
    }

    return light.diffuse * albedo * nDotL;
}


vec4 CalculateDirectional(Light light, vec3 normal, vec3 position, vec3 albedo, float depth)
{
    float visibility = 1.0f;

    // if(shadowMode == 0)
    // {
    //     visibility = 1.002 - shadow_occlussion(depth, normal, direction.xyz, position);

    // } else if(shadowMode == 1){
    //     vec3 voxelPos = WorldToVoxel(position);
    //     visibility = TraceShadow(voxelPos, normalize(light.direction), 1.0f);
    // } else {
    //     float a = 1.002 - shadow_occlussion(depth, normal, direction.xyz, position);
    //     vec3 voxelPos = WorldToVoxel(position);
    //     float b = TraceShadow(voxelPos, normalize(light.direction), 1.0f);
    //     visibility = min(a, b);
    // }

    vec3 voxelPos = WorldToVoxel(position);
    visibility = TraceShadow(voxelPos, normalize(light.direction), 1.0f);

    if(visibility == 0.0f) return vec4(0.0f); 

    return vec4(BRDF(light, normal, albedo) * visibility, visibility);
}

vec4 CalculateDirectLighting(vec3 position, vec3 normal, vec3 albedo, float depth)
{
    normal = normalize(normal);
    // world space grid voxel size
    float voxelWorldSize = 1.0 /  (voxelScale * volumeDimension);

    vec4 directLighting = vec4(0.0f, 0.0f, 0.0f, 0.0f);
    vec4 current =  vec4(0.0f); int count = 1;
    position = position + normal * voxelWorldSize * 0.5f;

    for (uint i = 0; i < numDirectionalLight; ++i)
    {
        current = CalculateDirectional(directionalLight[i], normal, position, albedo, depth);
        directLighting.rgb += current.rgb;
        directLighting.a += current.a; 
    }

    return directLighting;
}

vec3 EncodeNormal(vec3 normal)
{
    return normal * 0.5f + vec3(0.5f);
}

vec3 DecodeNormal(vec3 normal)
{
    return normal * 2.0f - vec3(1.0f);
}

void main()
{
	if(gl_GlobalInvocationID.x >= volumeDimension ||
		gl_GlobalInvocationID.y >= volumeDimension ||
		gl_GlobalInvocationID.z >= volumeDimension) return;

	ivec3 writePos = ivec3(gl_GlobalInvocationID);

	vec4 albedo = texelFetch(voxelAlbedo, writePos, 0);

    if(albedo.a < EPSILON) { return; }

    albedo.a = 0.0f;

    vec3 baseNormal = imageLoad(voxelNormal, writePos).xyz;

    vec3 normal = DecodeNormal(baseNormal);

    vec3 emissive = imageLoad(voxelEmissive, writePos).rgb;

    memoryBarrierImage();

    if(any(greaterThan(albedo.rgb, vec3(0.0f))))
    {
        vec3 wsPosition = VoxelToWorld(writePos);
        
        float near = 0.05f;
        float far = 120.0f;

        float z_linear = clamp((length(wsPosition - camera_position) - near) / far ,0.0, 1.0);
        float z_non_linear = ((near + far) * z_linear - (2 * near)) / ((near - far) * z_linear);
        albedo = CalculateDirectLighting(wsPosition, normal, albedo.rgb, z_non_linear);
    }


    float alpha = albedo.a;

    albedo.rgb += emissive;
    albedo.a = 1.0f;

    imageStore(voxelRadiance, writePos, albedo);
    imageStore(voxelNormal, writePos, vec4(baseNormal, alpha));
}